# Section 3: Getting Started with Hibernate and JPA Annotations.

Getting Started with Hibernate and JPA Annotations.

# What I Learned.

# 8. What is Hibernate.

<img src="hibernate.PNG"  alt="hibernate course" width="500"/>

1. This mapping shit will be solved by **Hibernate**.
    - Idea is that Java developers, are using **POJOS** rather than **SQL** language to persist objects.

- If **Object Mode** mapping is done correctly. We don't need to use low level languages or **JDBC** at all.

- **Hibernate** handles the 5 different mismatch problems.

# 9. Hello World with Hibernate and JPA Annotations.

<img src="helloWorldWithHibernate.PNG"  alt="hibernate course" width="500"/>

1. We are going create **Java object** into memory and persist it with **Hibernate**.
    - **Primary Key** get auto-generated for us.
    - `ID` will be mapped to `id` in POJO.
    - `TEXT` will be mapped to `text` in POJO.

- We are going to need **JDBC** connection, if we want to persist the object.
    - **Hibernate** gives us **Session** object for us.
        - It represents communication between **Server and Client**.

<img src="session.PNG"  alt="hibernate course" width="300"/>

1. We are using **Session** object to `persist` Message POJO to `Message Table`.

<img src="configuringSession.PNG"  alt="hibernate course" width="500"/>

1. `Session` object is build by `SessionFactory` from configuration.
2. Configuration for hibernate to connect to database.
3. Tells hibernate to optimize SQL for specific database.

<img src="mapping.PNG"  alt="hibernate course" width="500"/>

1. Finally, we provide **mapping** file, which tells how to map Java object to database table.
2. This file can hold many **configurations** for **Hibernate**.
3. `<session-factory></session-factory>` building **session-factory** is **resource intense** process, that why this is limited to **one instance per datasource**.

<img src="hibernateUtil.PNG"  alt="hibernate course" width="500"/>

1. We will build **Session Factory** object in `HibernateUtil` helper class.
2. Only **single** instance of `SessionFactory` object is created.
3. We need to add these dependencies for `classpath` for Hibernate.

<img src="mappingWithXML.PNG"  alt="hibernate course" width="500"/>

1. Mapping for `Message` class for the `Message` table. `package` tells where are the classes for mapping, we are having them in `domain` package.
2. `id` in Message class for `ID` in database table.
3. We have decide how values needs to be **generated**.
    - **Hibernate** support many ID generation strategies.
        - We are using `native` strategy here. Example in picture `<`
            - It gives **generation** responsibility for the underlying database.
            - **3.1**, `AUTO_INCREMENT` in database MySQL table, tells that `ID` is **auto incremented** by the database. So **unique** `ID` is **autogenerated** for every column.

<img src="insertingNewRow.PNG"  alt="hibernate course" width="500"/>

1. Now, when new row is inserted into `Message` table.
    - **Unique primary key** is generated and this `ID` is mapped into `id` of Message object by **Hibernate**.
2. **NOTICE**, no `id` is given here in **Java object**, therefore it comes from **MySQL**.
3. `text` is mapped into `TEXT` of database.
4. **NOTICE** the `string` datatype is ❌not❌:
    - ❌ SQL datatype ❌.
    - ❌ Java datatype ❌.
    - ✔️ Its **Hibernate Mapping Type** ✔️.
        - Takes care of **mapping** from **Java datatype** to **MySQL datatype**.
            - In practical sense, takes care of `String` to `VARCHAR`.
5. Also, **Hibernate** is smart to map without configuration `long` to the `BIGINT` type.

> Why use `BIGINT` for `ID` in db and `Long` for `id` in Java object? One could use `INT` and `int`.

- Many relational databases use `BIGINT` (64-bit integer) for primary keys to support large-scale data.

- Using `Long` in Java ensures compatibility with `BIGINT` in SQL databases.

<img src="namingOfMappingClasses.PNG"  alt="hibernate course" width="500"/>

1. The mapping file is called `Object/Relational Mapping Metadata` file.
2. The Java class is called `Persistent class`.

- ⚠️ Two classes needs to be in same **package**, here they are in `domain` **package** ⚠️.

<img src="PersistingObject.PNG"  alt="hibernate course" width="500"/>

1. The state of the `Message` Object at this point.

<img src="PersistingObjectSecond.PNG"  alt="hibernate course" width="500"/>

1. When calling `.save`, **Hibernate** will execute following **SQL query** behind the scenes.
    - Notice that the `id=1` of Java object is **not null** anymore, but the **Message** object is not inserted into the database yet.
    - Where is this `id=1` comes from, if there is no record in db?
        - Behind the scenes **Hibernate** is using **JDBC Transactions**.
            - This means `id` is generated by **MySQL**. These values are yet to be committed to the database, because nature of **transactions**.
2. This will be finished after calling `session.getTranaction().commit()` and the database will be also be updated.     

<img src="PersistingObjectThird.PNG"  alt="hibernate course" width="500"/>

1. We can also do the `JPA @annotation` mapping.
2. These two configuration types will have same kind of information.
3. Example of **@annotation** to do mappings in the Java object with `@Entity` annotation.
4. When using **annotation** remember to add, the configuration to the `<mapping> class="entity.Message"/>`. 
    - With **annotations**, we don't need the **XML** definition of mapping as in the top with ❌.

# 10. Lab - Hello World with Hibernate and JPA Annotations.

- In this lab we will have the following db. We will do `hello-word` application.

```
DROP DATABASE IF EXISTS `hello-world`; 
CREATE DATABASE `hello-world`; 

USE `hello-world`; 

CREATE TABLE `message` ( 
	`ID` BIGINT(20) NOT NULL AUTO_INCREMENT, 
	`TEXT` VARCHAR(255) NULL DEFAULT NULL, 
	PRIMARY KEY (`ID`) 
); 
```

- We will run the project **twice**.
    - Once for **legacy** `.xml` mapping.
    - Other run with the most **up to date** `@annotations`.

- Example of **legacy** `.xml` mapping files. Here the `<mapping resource="domain/Message.hbm.xml"/>` part.

```
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>

        <!-- Database connection settings -->
        <property name="connection.driver_class">com.mysql.jdbc.Driver</property>
        <property name="connection.url">jdbc:mysql://localhost:3306/hello-world</property>
        <property name="connection.username">root</property>
        <property name="connection.password">password</property>

        <!-- SQL dialect -->
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

        <!-- Echo all executed SQL to stdout -->
        <property name="show_sql">true</property>
        
        <!-- Use XML-based mapping metadata -->	
         <mapping resource="domain/Message.hbm.xml"/>
        
        <!-- Use Annotation-based mapping metadata -->
        <!-- <mapping class="entity.Message"/> -->
        
    </session-factory>
</hibernate-configuration>
```

- And the mapping for the `Message` **Object** to the `MESSAGE` **Table**.

```
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="domain">
	<class name="Message" table="MESSAGE">
		<id name="id" column="ID">
			<generator class="native" />
		</id>
		<property name="text" type="string" column="TEXT"/>
	</class>
</hibernate-mapping>
```

<img src="noticeTheSameDomain.PNG"  alt="hibernate course" width="400"/>

1. **NOTICE** the same domain package for **Java object** and the `.xml` configuration.

<img src="nullBeforeSaveEnds.PNG"  alt="hibernate course" width="600"/>

1. As you can see, the `Message` Java class, does not have `id` yet, before its `save` is called.

<img src="idAfterSave.PNG"  alt="hibernate course" width="600"/>

1. As you can see, the `Message` Java class, have now the `id`.

<img src="DbBeforeCommit.PNG"  alt="hibernate course" width="600"/>

1. Before transaction is `commit`:ed, there is no **Entry** in the Message table.

<img src="DbAfterCommit.PNG"  alt="hibernate course" width="600"/>

1. Now after `.commit()`, also the db will have the row entry!

- All this easiness is achieved by **Hibernate**, no need to write any **JDBC** code.

- Below example code, which were used for illustrating the workflow:

```
package client;

import org.hibernate.Session;

import domain.Message;
import util.HibernateUtil;

public class HelloWorldClient {
	public static void main(String[] args) {
		
				Session session = HibernateUtil.getSessionFactory().openSession();
        		session.beginTransaction();
        
        		Message message = new Message( "Hello World with Hibernate and JPA Annotations" );
        
        		session.save(message);    
        
        		session.getTransaction().commit();
        		session.close();
	
	}
}
```

- The same does works with `@Annotations`.

# 11. Note for Hibernate 5+ Users.


# 12. Note for Hibernate 6 Users.